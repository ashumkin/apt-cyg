
#!/bin/bash

# apt-cyg: install tool for cygwin similar to debian apt-get
#
# Copyright (C) 2005-9, Stephen Jungels
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# (http://www.fsf.org/licensing/licenses/gpl.html)

# this script requires some packages

WGET=`which wget 2> /dev/null`
BZIP2=`which bzip2 2> /dev/null`
TAR=`which tar 2> /dev/null`
GAWK=`which awk 2> /dev/null`
if test "-$WGET-" = "--" || test "-$BZIP2-" = "--" || test "-$TAR-" = "--" \
  || test "-$GAWK-" = "--"
then
  echo You must install wget, tar, gawk and bzip2 to use apt-cyg. >&2
  exit 1
fi
APT_CYG="$0"
if test "${APT_CYG:0:1}" != "/"
then
	APT_CYG="$(pwd)/$APT_CYG"
fi

function usage()
{
  cat <<EOF
  apt-cyg: Installs and removes Cygwin packages.
  "apt-cyg install <package names>" to install packages
  "apt-cyg remove <package names>" to remove packages
  "apt-cyg update" to update setup.ini
  "apt-cyg show" to show installed packages
  "apt-cyg find <patterns>" to find packages matching patterns
  "apt-cyg describe <patterns>" to describe packages matching patterns
  "apt-cyg packageof <commands or files>" to locate parent packages
Options:
  --prefix, -p <prefix> : prefix to install packages to (for debug purposes; must be set first)
  --mirror, -m <url>    : set mirror
  --cache, -c <dir>     : set cache
  --fetch               : fetch files only (not install)
  --file, -f <file>     : read package names from file
  --force, -F           : force install (for "install" only)
  --noupdate, -u        : don't update setup.ini from mirror
  --help                : show this help
  --version             : show version info
EOF
}



function version()
{
  cat <<EOF
apt-cyg version 0.57.2
Written by Stephen Jungels

Copyright (c) 2005-9 Stephen Jungels.  Released under the GPL.
Copyright (c) 2013 Alexey Shumkin.
EOF
}


function findworkspace()
{
  # default working directory and mirror

  mirror=ftp://mirror.mcs.anl.gov/pub/cygwin
  cache=/setup

  # work wherever setup worked last, if possible

  if test -e $SETUP_DIR/last-cache
  then
    tmp="`head -1 $SETUP_DIR/last-cache`"
    cache="`cygpath -au "$tmp"`"
  fi

  if test -e $SETUP_DIR/last-mirror
  then
    mirror="`head -1 $SETUP_DIR/last-mirror`"
  fi
  mirrordir="`echo "$mirror" | sed -e "s/:/%3a/g" -e "s:/:%2f:g"`"

  echo Working directory is $cache
  echo Mirror is $mirror
  if mkdir -p "$cache/$mirrordir"
  then
      cd "$cache/$mirrordir"
  else
      echo Cannot create cache dir. Exiting... >&2
      exit 1
  fi
}


function getsetup()
{
  if test "$noscripts" == "0" -a "$noupdate" == "0"
  then
    touch setup.ini
    mv setup.ini setup.ini-save
    wget -N $mirror/setup.bz2
    if test -e setup.bz2 && test $? -eq 0
    then
      bunzip2 setup.bz2
      mv setup setup.ini
      echo Updated setup.ini
    else
      wget -N $mirror/setup.ini
      if test -e setup.ini && test $? -eq 0
      then
        echo Updated setup.ini
      else
        mv setup.ini-save setup.ini
        echo Error updating setup.ini, reverting
      fi
    fi
  fi
}


function checkpackages()
{
  if test "-$packages-" = "--"
  then
    echo Nothing to do, exiting
    exit 0
  fi
}

function escape_package_name()
{
    # escape special chars in package name (if any)
    echo $1 | sed -e "s/[+.*()&?]/\\\\&/g"
}

function gen_tmp_awk()
{
    tmp_awk="/tmp/awk.$$"
}

function fetch_and_install()
{
    fetch_only="$1"
    for pkg in $packages
    do

    if test "$fetch_only" -eq 0
    then
        already=`grep -c "^$pkg " $INSTALLED_DB`
        if test $already -ge 1
        then
          if test $force -eq 0
          then
              echo Package $pkg is already installed, skipping
              continue
          else
              echo Package $pkg is already installed but forced reinstall
          fi
        fi
        echo ""
    fi
    echo Fetching $pkg

    # look for package and save desc file

    pkg_desc="/tmp/apt-cyg.$pkg.desc"
    cat setup.ini | awk > "$pkg_desc" -v package="$pkg" \
      'BEGIN{RS="\n\n@ "; FS="\n"} {if ($1 == package) {desc = $0; px++}} \
       END {if (px == 1 && desc != "") print desc; else print "Package not found"}'

    desc=`< "$pkg_desc"`
    if test "-$desc-" = "-Package not found-"
    then
      echo Package $pkg not found or ambiguous name, exiting >&2
      rm "$pkg_desc"
      exit 1
    fi
    echo Found package $pkg

    # download and unpack the bz2 file

    # pick the latest version, which comes first
    install=`cat "$pkg_desc" | awk '/^install: / { print $2; exit }'`

    if test "-$install-" = "--"
    then
      echo "Could not find \"install\" in package description: obsolete package?" >&2
      exit 1
    fi

    pkg_dir=$(dirname "$install")
    file=$(basename "$install")
    mkdir -p "$pkg_dir"
    pushd "$pkg_dir" 1>/dev/null
    wget -nc $mirror/$install

    # check the md5
    digest=`cat "$pkg_desc" | awk '/^install: / { print $4; exit }'`
    digactual=`md5sum $file | awk '{print $1}'`
    if ! test "$digest" = "$digactual"
    then
      echo MD5 sum did not match, exiting >&2
      exit 1
    fi

    if test "$fetch_only" -eq 1
    then
        popd 1>/dev/null
        continue
    fi

    echo "Unpacking..."
    cat $file | bunzip2 | tar > "$SETUP_DIR/$pkg.lst" xvf - -C $prefix/
    gzip -f "$SETUP_DIR/$pkg.lst"
    popd 1>/dev/null


    # update the package database
    gen_tmp_awk
    cat $INSTALLED_DB | awk > $tmp_awk -v pkg="$pkg" -v bz=$file \
      "BEGIN{ins=$already} {if (ins < 1 && pkg < \$1) {print pkg \" \" bz \" 0\"; ins=1}; print \$0} \
       END{if (ins < 1) print pkg \" \" bz \" 0\"}"
    mv $INSTALLED_DB $INSTALLED_DB-save
    mv $tmp_awk $INSTALLED_DB


    # recursively install required packages

    echo > $tmp_awk '/^requires: / {s=gensub("(requires: )?([^ ]+) ?", "\\2 ", "g", $0); print s}'
    requires=`cat "$pkg_desc" | awk -f $tmp_awk`

    warn=0
    if ! test "-$requires-" = "--"
    then
      echo Package $pkg requires the following packages, installing:
      echo $requires
      for package in $requires
      do
        already=`grep -c "^$package " $INSTALLED_DB`
        if test $already -ge 1
        then
          echo Package $package is already installed, skipping
          continue
        fi
        "$APT_CYG" --prefix "$prefix" --noscripts install $package
        if ! test $? = 0 ; then warn=1; fi
      done
    fi
    if ! test $warn = 0
    then
      echo "Warning: some required packages did not install, continuing"
    fi

    # run all postinstall scripts

    pis=`ls /etc/postinstall/*.sh 2>/dev/null | wc -l`
    if test $pis -gt 0 && ! test $noscripts -eq 1
    then
      echo Running postinstall scripts
      for script in /etc/postinstall/*.sh
      do
        $script
        mv $script $script.done
      done
    fi

    echo Package $pkg installed
    rm "$pkg_desc"

    done
}

function show_installed_packages()
{
    q_verbose=$1
    query="$(escape_package_name "$2")"
    # remove ".tar.bz2" extension
    # print version (cut from "<pkg> <pkg>-version" string)
    # sort list (started with underscores are last)
    cat $INSTALLED_DB | awk -v verbose=$q_verbose -v query="$query" \
        '/[^ ]+ [^ ]+ 0/ { if (length(query) == 0 || $1 ~ query ) { NF=verbose+1; if (NF > 1) { sub(/\.tar\.bz2$/, "", $2); r=$1; gsub(/[+.*()&#?]/, "\\\\&", r); r="^"r"-"; sub(r, "", $2) }; print } }' | sort | sed -e '/^_/{$!{H;d}}; $G' | sed -e '/^$/d'
}

function show_available_packages()
{
    q_verbose=$1
    query="$(escape_package_name "$2")"
    # print version (found "version:" field"
    # sort list (started with underscores are last)
    cat setup.ini | awk -v query="$query" -v verbose=$q_verbose -v version_re="^version: " \
        'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} { if ($1 !~ "^#" && $1 ~ query) { if (verbose == 0) { NF=1 } else { for(i=3; i<=NF; i++) { if ($i ~ version_re) { $2=$i; NF=2; sub(version_re, "", $2) } } }; if (NF>2) NF=1; print } }' | sort | sed -e '/^_/{$!{H;d}}; $G' | sed -e '/^$/d'
}

function init_vars()
{
    SETUP_DIR=$prefix/etc/setup
    if test -n "$prefix"
    then
        mkdir -p $SETUP_DIR
    fi
    INSTALLED_DB=$SETUP_DIR/installed.db
}

# process options

# on Linux box emulate `cygpath`
if ! which cygpath &>/dev/null
then
    function cygpath()
    {
        echo "$2"
    }
fi
noscripts=0
noupdate=0
fetch_only=0
file=""
force=0
verbose=0
dofile=0
command=""
filepackages=""
packages=""
prefix=""

# initialize SETUP_DIR and INSTALLED_DB
init_vars

while test $# -gt 0
do
  case "$1" in

    --prefix|-p)
        prefix="$2"
        # REinitialize SETUP_DIR and INSTALLED_DB
        init_vars
        shift; shift
    ;;

    --mirror|-m)
      echo "$2" > $SETUP_DIR/last-mirror
      shift ; shift
    ;;

    --cache|-c)
      cygpath -aw "$2" > $SETUP_DIR/last-cache
      shift ; shift
    ;;

    --noscripts)
      noscripts=1
      shift
    ;;

    --noupdate|-u)
      noupdate=1
      shift
    ;;

    --help)
      usage
      exit 0
    ;;

    --verbose)
      verbose=1
      shift
    ;;

    --version)
      version
      exit 0
    ;;

    --fetch)
        fetch_only=1
        shift
    ;;

    --file|-f)
      if ! test "-$2-" = "--"
      then
        file="$2"
        dofile=1
        shift
      else
        echo 1>&2 No file name provided, ignoring $1
      fi
      shift
    ;;

	--force|-F)
		force=1
		shift
	;;

    update|show|find|describe|packageof|install|remove)
      if test "-$command-" = "--"
      then
        command=$1
      else
        packages="$packages $1"
      fi
      shift

    ;;

    *)
      packages="$packages $1"
      shift

    ;;

  esac
done


if test $dofile = 1
then
  if test -f "$file"
  then
    filepackages="$filepackages `cat "$file" | awk '{printf "%s ", $0}'`"
  else
    echo File $file not found, skipping >&2
  fi
  packages="$packages $filepackages"
fi


case "$command" in

  update)

    findworkspace
    getsetup

  ;;


  show)

    echo 1>&2 The following packages are installed:
    show_installed_packages $verbose

  ;;


  find)

    checkpackages
    findworkspace
    getsetup

    for pkg in $packages
    do
      echo ""
      echo Searching for installed packages matching $pkg:
      show_installed_packages $verbose $pkg
      echo ""
      echo Searching for installable packages matching $pkg:
      show_available_packages $verbose $pkg
    done

  ;;


  describe)

    checkpackages
    findworkspace
    getsetup
    for pkg in $packages
    do
      echo ""
      cat setup.ini | awk -v query="$pkg" \
        'BEGIN{RS="\n\n@ "; FS="\n"; ORS="\n"} {if ($1 ~ query) {print $0 "\n"}}'
    done

  ;;


  packageof)

    checkpackages
    for pkg in $packages
    do
      key=`which "$pkg" 2>/dev/null | sed "s:^/::"`
      if test "-$key-" = "--"
      then
        key="$pkg"
      fi
      for manifest in $SETUP_DIR/*.lst.gz
      do
        found=`cat $manifest | gzip -d | grep -c "$key"`
        if test $found -gt 0
        then
          package=`echo $manifest | sed -e "s:$SETUP_DIR/::" -e "s/.lst.gz//"`
          echo Found $key in the package $package
        fi
      done
    done

  ;;


  install)

    checkpackages
    findworkspace
    getsetup
    fetch_and_install $fetch_only

  ;;


  remove)

    checkpackages
    for pkg in $packages
    do

    already=`grep -c "^$pkg " $INSTALLED_DB`
    if test $already = 0
    then
      echo Package $pkg is not installed, skipping
      continue
    fi

    dontremove="cygwin coreutils gawk bzip2 tar wget bash"
    for req in $dontremove
    do
      if test "-$pkg-" = "-$req-"
      then
        echo apt-cyg cannot remove package $pkg, exiting >&2
        exit 1
      fi
    done

    if ! test -e "$SETUP_DIR/$pkg.lst.gz"
    then
      echo Package manifest missing, cannot remove $pkg. Exiting >&2
      exit 1
    fi
    echo Removing $pkg

    # run preremove scripts

    if test -e "/etc/preremove/$pkg.sh"
    then
      "/etc/preremove/$pkg.sh"
      rm "/etc/preremove/$pkg.sh"
    fi

    cat "$SETUP_DIR/$pkg.lst.gz" | gzip -d | awk '/[^\/]$/ {print "rm -f \"/" $0 "\""}' | sh
    rm "$SETUP_DIR/$pkg.lst.gz"
    rm -f /etc/postinstall/$pkg.sh.done
    gen_tmp_awk
    cat $INSTALLED_DB | awk > $tmp_awk -v pkg="$pkg" '{if (pkg != $1) print $0}'
    mv $INSTALLED_DB $INSTALLED_DB-save
    mv $tmp_awk $INSTALLED_DB
    echo Package $pkg removed

    done

  ;;

  *)

    usage

  ;;

esac

# vim: set filetype=sh:
